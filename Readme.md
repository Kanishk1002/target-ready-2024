# TargetReady 2024

## Git repositories of participants (for assignments)

- [Jaya Singh](https://github.com/p-jaya/Target-Ready)
- [Kanishk Vanga](https://github.com/Kanishk1002/Target_Ready_2024)
- [Nirbhai Sai](https://github.com/NIRBHAI-SAI/assignments/tree/master)
- [Kishor Kumar Behera](https://github.com/kishor1010/target-ready-2024)
- [chandini rongali](https://github.com/Chandini3/target-2024)
- [Ankit Kumar](https://github.com/Ankitkumar803/Target-Ready-2024)
- [Sai Tejaswi K](https://github.com/Saitejaswi-K/Target-Ready-2024)
- [Sahel Riaz](https://github.com/sahel-riaz/target-ready-2024)
- [Bharath Sajan](https://github.com/BharathSajan/target-ready)
- [Mohammad Affan Savanur](https://github.com/ROckx14/TargetReady_2024)
- [Amogh pandey](https://github.com/amoghpandey2001)
- [Susmitha Utla](https://github.com/SusmithaUtla/Target-ready-2024)
- [Swayamshu Swain](https://github.com/Swayamshu/target-ready-2024)
- [Ujjwal Bansal](https://github.com/ujjwalban/Target_Ready)
- [Harshit Soni](https://github.com/harshit-333/target-ready-2024)
- [Nimitha Reddy Magatala](https://github.com/nimithareddy03/target-ready-2024)
- [Pavan Kumar G](https://github.com/pavankumar0715/target-ready-2024)
- [Koustubh Mane](https://github.com/Koustubh-Mane1/Target_Ready)
- [Lara](https://github.com/Lara369/target-ready)
- [Ayushi Gupta](https://github.com/Ayushi-gupta1225/Targetready-2024)

## Software Setup:

- JDK 17 or later
- IntelliJ IDEA
- Visual Studio Code
- MySQL Community Server
- Maven 3.9 or later
- Postman
- Git SCM

## Prerequisites:

To fully benefit from this course, students should have:

1. Basic knowledge of programming concepts, preferably in Java or a similar object-oriented language.
2. Familiarity with basic database concepts such as tables, rows, columns, and SQL queries is helpful but not mandatory.
3. Prior exposure to web development concepts like HTTP, RESTful APIs, and MVC architecture would be advantageous for understanding Spring Boot sessions.
4. Eagerness to learn and willingness to engage in hands-on coding exercises and projects throughout the course.

## Duration

- 90 hours
- 30 sessions
- 3 hours per session
- 3 sessions per week
  - Mondays, Wednesdays and Fridays between 5:30 PM and 8:30 PM

## Distribution of time

- Java (intermediate to slightly advanced) - 9 sessions
- Kotlin - 9 sessions
- DSA - 6 sessions
- Introduction to React js - 4 sessions
- Introduction to messaging and Kafka - 2 sessions

## Detailed session-wise outline

### Session 1: Java Programming Fundamentals

- Review of basic Java syntax and concepts
- Data types, variables, and operators
- Control flow: conditionals (if-else, switch-case) and loops (for, while, do-while)
- Methods and functions
- Classes and objects, constructors and method overloading
- Inheritance and method overriding
- Introduction to access modifiers
- Interfaces and abstract classes
- Enumerations and nested classes

### Session 2: Exceptions Handling

- Understanding exceptions and error handling
- Handling exceptions using try-catch blocks
- Throwing and propagating exceptions
- Multiple catch blocks and finally block
- Try with resources
- Best practices for exception handling

### Session 3: Input-Output (IO) Operations

- Overview of Java IO API
- Working with streams: InputStream, OutputStream, Reader, Writer
- File input and output operations
- Reading and writing text files
- Binary file handling in Java
- Working with directories and files
- File manipulation: creating, deleting, renaming files
- File searching and filtering
- Managing file permissions and attributes
- Handling file I/O errors and exceptions

### Session 4: Introduction to Collections Framework

- Overview of Java Collections Framework (JCF)
- Lists: ArrayList, LinkedList
- Sets: HashSet, TreeSet
- Maps: HashMap, TreeMap
- Iterators and enhanced for loops

### Session 5: Streams and Functional Interfaces

- Introduction to streams in Java
- Stream operations: filter, map, reduce
- Working with functional interfaces
- Lambda expressions in Java
- Stream API best practices

### Session 6: More on Collections

- Collection interfaces: Collection, List, Set, Map
- Collection algorithms and utility classes
- Sorting and searching collections
- Customizing and optimizing collections
- Practical exercises and case studies

### Session 7: Introduction to JPA (Java Persistence API)

- Understanding ORM (Object-Relational Mapping)
- Introduction to JPA and its architecture
- Setting up JPA with Hibernate or EclipseLink
- Mapping entities to database tables
- Performing basic CRUD operations using JPA

### Session 8: Advanced JPA Concepts

- Entity relationships: One-to-One, One-to-Many, Many-to-One, Many-to-Many
- Lazy loading vs. eager loading
- Fetch strategies and performance optimization
- Transaction management in JPA
- Using JPQL (Java Persistence Query Language)

### Session 9: JPA Querying and Optimization

- Advanced querying with JPQL and Criteria API
- Named queries and dynamic queries
- Caching and query optimization techniques
- Handling concurrency issues in JPA applications
- Profiling and performance tuning with JPA

### Session 10: Introduction to Kotlin

- Overview of Kotlin
- History and purpose of Kotlin
- Setting up Kotlin development environment (IDE installation)
- Basic syntax and structure of Kotlin
- Variables and data types
- Basic operations and expressions

### Session 11: Control Flow, Functions

- Conditional statements (if, else, when)
- Looping constructs (for, while, do-while)
- Introduction to functions in Kotlin
- Function declaration and invocation
- Parameters and return types
- Scope and visibility of variables

### Session 12: OOP in Kotlin

- Introduction to object-oriented programming concepts
- Classes and objects in Kotlin
- Properties and methods
- Constructors and initialization
- Inheritance and polymorphism
- Interfaces and abstract classes

### Session 13: Advanced Kotlin Concepts

- Exception handling in Kotlin
- Null safety and handling nullable types
- Collections and arrays
- Lambdas and higher-order functions
- Extension functions and properties
- Kotlin Standard Library overview

### Session 14: Introduction to Asynchronous Programming

- Understanding synchronous vs. asynchronous code
- Need for asynchronous programming
- Overview of coroutines and their benefits
- Setting up Kotlin project for coroutine support
- Basics of coroutine creation and launch
- Coroutine scopes and contexts
- Understanding different coroutine builders (launch, async, runBlocking, etc.)
- Introduction to Dispatchers and their types (Main, IO, Default, Unconfined)
- Handling coroutine cancellation
- Timeout and its implementation in coroutines

### Session 15: Coroutine Context, Scope, Concurrency and Exceptions

- Exploring CoroutineContext and CoroutineScope
- Customizing coroutine context for specific tasks
- Concurrent coroutines execution
- Synchronizing coroutine execution using Mutex and Semaphore
- Dealing with exceptions in coroutines
- Exception handling strategies

### Session 16: Coroutine Flows, Channels and Patterns

- Introduction to cold streams using Flow
- Asynchronous data streams and their operators
- Understanding communication channels in coroutines
- Implementing producer-consumer scenarios using channels
- SupervisorScope and structured concurrency
- Coroutine fan-out and fan-in patterns

### Session 17: Unit testing in Kotlin

- Understanding the purpose and importance of unit testing
- Basic concepts: test cases, assertions, test suites
- Configuring testing dependencies in Kotlin projects
- Choosing testing frameworks (JUnit, Spek, etc.)
- Writing test functions in Kotlin
- Grouping tests using test suites and test classes
- Using built-in assertions and matchers
- Custom assertions and matchers
- Understanding test doubles
- Using libraries like Mockito for creating mocks

### Session 18: Test-Driven Development (TDD)

- Principles and benefits of TDD
- Writing tests before implementation
- Testing Kotlin-specific constructs (coroutines, data classes, etc.)
- Handling nullable types in tests
- Writing integration tests for Kotlin applications
- Setup and teardown for integration tests
- Measuring code coverage
- Generating test reports
- Writing clean, maintainable tests
- Test organization and naming conventions
- Continuous Integration (CI) and testing automation

### Session 19: Introduction to Data Structures and Algorithms

- Overview of the course objectives and structure
- Importance and relevance of Data Structures and Algorithms
- Basic terminologies: Data, Data Structures, Algorithms
- Characteristics of good algorithms
- Big O notation and time complexity analysis
- Introduction to different types of data structures: Arrays, Linked Lists, Stacks, Queues

### Session 20: Arrays and Linked Lists

- Review of arrays: Declaration, Initialization, Accessing elements, Insertion, Deletion, Searching
- Advantages and limitations of arrays
- Introduction to Linked Lists: Singly Linked Lists, Doubly Linked Lists
- Operations on Linked Lists: Insertion, Deletion, Searching
- Comparison between arrays and linked lists

### Session 21: Stacks and Queues

- Introduction to Stacks: Definition, Operations (Push, Pop, Peek), Applications
- Implementation of Stack using arrays and linked lists
- Introduction to Queues: Definition, Operations (Enqueue, Dequeue), Applications
- Implementation of Queue using arrays and linked lists
- Comparison between stacks and queues

### Session 22: Trees and Binary Trees

- Introduction to Trees: Terminologies (Root, Node, Leaf, Parent, Child), Types of Trees
- Introduction to Binary Trees: Definition, Properties, Operations (Traversal, Insertion, Deletion)
- Binary Tree Traversal: Inorder, Preorder, Postorder
- Special types of Binary Trees: Binary Search Trees (BST), Balanced Binary Trees (AVL Trees)

### Session 23: Sorting Algorithms

- Introduction to Sorting: Importance, Terminologies (Stable Sorting, Comparison Sorting)
- Bubble Sort: Algorithm, Implementation, Time Complexity
- Selection Sort: Algorithm, Implementation, Time Complexity
- Insertion Sort: Algorithm, Implementation, Time Complexity
- Comparison of sorting algorithms

### Session 24: Searching Algorithms and Conclusion

- Introduction to Searching: Linear Search, Binary Search
- Linear Search: Algorithm, Implementation, Time Complexity
- Binary Search: Algorithm, Implementation, Time Complexity
- Comparison of searching algorithms
- Review of course content and key takeaways
- Discussion on further learning resources and career opportunities in DSA

### Session 25: Understanding React.js Fundamentals

- Introduction to React.js and its significance in modern web development
- Overview of JavaScript ES6 features used in React.js
- Setting up the development environment (Node.js, npm, create-react-app)
- Introduction to JSX (JavaScript XML)
- Understanding components in React.js (functional vs. class-based components)
- State and props in React.js components

### Session 26: React.js Component Lifecycle and State Management

- Understanding the lifecycle of React.js components
- Exploring component lifecycle methods (e.g., componentDidMount, componentDidUpdate)
- Handling events in React.js components
- Introduction to state management in React.js using useState and useEffect hooks
- Managing state across components using props and lifting state up

### Session 27: React.js Routing and Hooks

- Introduction to React Router for handling client-side routing
- Configuring routes in a React.js application
- Implementing navigation in React.js using Link and NavLink components
- Introduction to React.js hooks (useState, useEffect, useContext)
- Implementing custom hooks for reusable logic

### Session 28: Advanced Topics in React.js

- Introduction to advanced React.js concepts (e.g., context API, higher-order components)
- Working with forms in React.js (controlled vs. uncontrolled components)
- Introduction to styling in React.js (inline styles, CSS modules, styled-components)
- Best practices and tips for building scalable React.js applications
- Q&A and Recap of the course content

### Session 29: Understanding Messaging Systems and Introduction to Kafka

- Introduction to Messaging Systems

  - Definition and significance
  - Types of messaging systems: synchronous vs. asynchronous
  - Use cases and applications in real-world scenarios

- Fundamentals of Apache Kafka

  - Overview of Kafka: features and benefits
  - Kafka architecture: topics, partitions, brokers, producers, consumers
  - Basic concepts and terminologies

- Setting Up Kafka Environment

  - Installation of Kafka on local machines
  - Configuration and setup for development environment
  - Practical exercises to familiarize with Kafka basics

### Session 30: Core Concepts and Hands-On Practice with Kafka

- Kafka Producer and Consumer

  - Understanding producers and consumers in Kafka
  - Writing simple Kafka producers and consumers
  - Message publishing and consumption: demonstration and exercises

- Kafka Topics and Partitions

  - Deep dive into Kafka topics and partitions
  - Partitioning strategies and their implications
  - Hands-on activities to work with topics and partitions

- Kafka Ecosystem Overview

  - Introduction to Kafka ecosystem components (Kafka Connect, Kafka Streams)
  - Overview of their functionalities and use cases

- Real-World Examples and Use Cases

  - Case studies showcasing how Kafka is used in various industries
  - Discussion on handling real-time data streams and event-driven architectures
